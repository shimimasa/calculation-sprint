#!/usr/bin/env node
const { execFileSync } = require('node:child_process');
const fs = require('node:fs');
const path = require('node:path');

const ROOT_DIR = process.cwd();
const TARGET_DIRS = ['src', 'tools', 'scripts'];
const EXTENSIONS = new Set(['.js', '.mjs']);

const collectFiles = (dirPath, results) => {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.name === 'node_modules' || entry.name.startsWith('.')) {
      continue;
    }
    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      collectFiles(fullPath, results);
      continue;
    }
    if (EXTENSIONS.has(path.extname(entry.name))) {
      results.push(fullPath);
    }
  }
};

const lintFiles = () => {
  console.log('[gate-ci] lint: node --check');
  const files = [];
  for (const dir of TARGET_DIRS) {
    const fullDir = path.join(ROOT_DIR, dir);
    if (!fs.existsSync(fullDir)) {
      continue;
    }
    collectFiles(fullDir, files);
  }
  files.sort();
  for (const file of files) {
    execFileSync(process.execPath, ['--check', file], { stdio: 'inherit' });
  }
};

const readPackageJson = () => {
  const pkgPath = path.join(ROOT_DIR, 'package.json');
  try {
    const raw = fs.readFileSync(pkgPath, 'utf8');
    const parsed = JSON.parse(raw);
    return parsed && typeof parsed === 'object' ? parsed : null;
  } catch (error) {
    return null;
  }
};

const maybeRunNpmTest = () => {
  const pkg = readPackageJson();
  const hasTestScript = Boolean(pkg?.scripts && typeof pkg.scripts.test === 'string' && pkg.scripts.test.length > 0);
  if (!hasTestScript) {
    console.warn('[gate-ci] skip: no "test" script in package.json');
    return;
  }
  execFileSync(process.platform === 'win32' ? 'npm.cmd' : 'npm', ['test'], { stdio: 'inherit' });
};

lintFiles();
maybeRunNpmTest();
